// Code generated by goderive DO NOT EDIT.

package micro

import (
	ast "github.com/awalterschulze/gominikanren/sexpr/ast"
)

// deriveTupleO returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTupleO(v0 string, v1 string, v2 string, v3 bool) func() (string, string, string, bool) {
	return func() (string, string, string, bool) {
		return v0, v1, v2, v3
	}
}

// deriveTupleE returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTupleE(v0 string, v1 string, v2 string, v3 string) func() (string, string, string, string) {
	return func() (string, string, string, string) {
		return v0, v1, v2, v3
	}
}

// deriveTuple3 returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTuple3(v0 string, v1 string, v2 string) func() (string, string, string) {
	return func() (string, string, string) {
		return v0, v1, v2
	}
}

// deriveFmapR returns a list where each element of the input list has been morphed by the input function.
func deriveFmapR(f func(*ast.List) *ast.SExpr, list []*ast.List) []*ast.SExpr {
	out := make([]*ast.SExpr, len(list))
	for i, elem := range list {
		out[i] = f(elem)
	}
	return out
}

// deriveFmaps returns a list where each element of the input list has been morphed by the input function.
func deriveFmaps(f func(*ast.List) string, list []*ast.List) []string {
	out := make([]string, len(list))
	for i, elem := range list {
		out[i] = f(elem)
	}
	return out
}
