// Code generated by goderive DO NOT EDIT.

package micro

import (
	ast "github.com/awalterschulze/gominikanren/sexpr/ast"
	"sort"
)

// deriveTupleO returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTupleO(v0 string, v1 string, v2 Substitutions, v3 bool) func() (string, string, Substitutions, bool) {
	return func() (string, string, Substitutions, bool) {
		return v0, v1, v2, v3
	}
}

// deriveTupleE returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTupleE(v0 string, v1 string, v2 Substitutions, v3 Substitutions) func() (string, string, Substitutions, Substitutions) {
	return func() (string, string, Substitutions, Substitutions) {
		return v0, v1, v2, v3
	}
}

// deriveTuple3 returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTuple3(v0 string, v1 string, v2 string) func() (string, string, string) {
	return func() (string, string, string) {
		return v0, v1, v2
	}
}

// deriveTuple3S returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTuple3S(v0 string, v1 Substitutions, v2 string) func() (string, Substitutions, string) {
	return func() (string, Substitutions, string) {
		return v0, v1, v2
	}
}

// deriveSorted sorts the slice inplace and also returns it.
func deriveSorted(list []string) []string {
	sort.Strings(list)
	return list
}

// deriveKeys returns the keys of the input map as a slice.
func deriveKeys(m map[string]*ast.SExpr) []string {
	keys := make([]string, 0, len(m))
	for key := range m {
		keys = append(keys, key)
	}
	return keys
}

// deriveFmapRs returns a list where each element of the input list has been morphed by the input function.
func deriveFmapRs(f func(*State) *ast.SExpr, list []*State) []*ast.SExpr {
	out := make([]*ast.SExpr, len(list))
	for i, elem := range list {
		out[i] = f(elem)
	}
	return out
}

// deriveFmaps returns a list where each element of the input list has been morphed by the input function.
func deriveFmaps(f func(*State) string, list []*State) []string {
	out := make([]string, len(list))
	for i, elem := range list {
		out[i] = f(elem)
	}
	return out
}
